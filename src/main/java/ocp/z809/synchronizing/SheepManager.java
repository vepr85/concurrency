package ocp.z809.synchronizing;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * Created by abyakimenko on 06.10.2016.
 * <p>
 * ***************** Atomicity ******************
 * **********************************************
 * <p>
 * Хотя многие это знают, считаю необходимым напомнить, что на некоторых платформах некоторые операции записи могут
 * оказаться неатомарными. То есть, пока идёт запись значения одним потоком, другой поток может увидеть какое-то
 * промежуточное состояние. За примером далеко ходить не нужно — записи тех же long и double, если они не объявлены
 * как volatile, не обязаны быть атомарными и на многих платформах записываются в две операции: старшие и младшие 32
 * бита отдельно. (см. http://docs.oracle.com/javase/specs/#28733)
 * <p>
 * ***************** Visibility ******************
 * ***********************************************
 * <p>
 * В старой JMM у каждого из запущенных потоков был свой кеш (working memory), в котором хранились некоторые состояния
 * объектов, которыми этот поток манипулировал. При некоторых условиях кеш синхронизировался с основной памятью
 * (main memory), но тем не менее существенную часть времени значения в основной памяти и в кеше могли расходиться.
 * В новой модели памяти от такой концепции отказались, потому что то, где именно хранится значение, вообще никому
 * не интересно. Важно лишь то, при каких условиях один поток видит изменения, выполненные другим потоком.
 * Кроме того, железо и без того достаточно умно, чтобы что-то кешировать, складывать в регистры и вытворять
 * прочие операции.
 * Важно отметить, что, в отличие от того же C++, «из воздуха» (out-of-thin-air) значения никогда не берутся:
 * для любой переменной справедливо, что значение, наблюдаемое потоком, либо было ранее ей присвоено,
 * либо является значением по умолчанию.
 * <p>
 * !!! Один поток может в какой-то момент временно сохранить значение некоторых полей не в основную память, а в регистры или
 * локальный кэш процессора, таким образом второй поток, выполняемый на другом процессоре, читая из основной памяти,
 * может не увидеть последних изменений поля. И наоборот, если поток на протяжении какого-то времени работает с регистрами
 * и локальными кэшами, читая данные оттуда, он может сразу не увидеть изменений, сделанных другим потоком в основную память.
 * <p>
 * <p>
 * <p>
 * ***************** Reordering ******************
 * ***********************************************
 * <p>
 * Но и это, как говорится, ещё не всё. Если вы сделаете заказ прямо сейчас, то ваши инструкции переставят местами совершенно бесплатно!
 * Процессоры проявляют невероятную проворность в оптимизации исполнения инструкций. В этом им также помогает компилятор и JIT.
 * Одним из примечательных эффектов может оказаться то, что действия, выполненные одним потоком, другой поток увидит в
 * другом порядке. Эту фразу довольно сложно понять, просто прочитав, потому приведу пример. Пусть есть такой код:
 * <p>
 * public class ReorderingSample {
 * boolean first = false;
 * boolean second = false;
 * <p>
 * void setValues() {
 * first = true;
 * second = true;
 * }
 * <p>
 * void checkValues() {
 * while(!second);
 * assert first;
 * }
 * }
 * <p>
 * И в этом коде из одного потока вызывается метод checkValues, а из другого потока — setValues. Казалось бы, код должен
 * выполняться без проблем, ведь полю second значение true присваивается позже, чем полю first, и потому когда
 * (точнее, если) мы видим, что, второе поле истинно, то и первое тоже должно быть таким. Но не тут-то было.
 * <p>
 * Хотя внутри одного потока об этом можно не беспокоиться, в многопоточной среде результаты операций, произведённых
 * другими потоками, могут наблюдаться не в том порядке. Чтобы не быть голословным, я хотел добиться того, чтобы на
 * моей машине сработал assertion, но мне это не удавалось настолько долго (нет, я не забыл указать при запуске ключ -ea),
 * что, отчаявшись, я обратился с вопросом «а как же всё-таки спровоцировать reordering» к небезызвестным
 * перформанс-инженерам. Так на мой вопрос ответил Сергей Куксенко:
 * На машинах с TSO (к коим относится x86) довольно сложно показать
 * ломающий reordering. Это можно показать на каком-нибудь ARM'е или
 * PowerPC. Еще можно сослаться на Альфу — процессор с самыми слабыми правилами ордеринга. Альфа — это был ночной кошмар
 * разработчиков компиляторов и ядер операционной системы. Счастье, что он таки умер. В сети можно найти массы историй об этом.
 * <p>
 * Классический пример:
 * (пример аналогичен приведённому выше — прим. автора)
 * … на x86 будет отрабатывать корректно всегда, ибо если вы увидели
 * стор в «b», то увидите и стор в «a».
 * <p>
 * <p>
 * <p>
 * <p>
 * !!!
 * Для увеличения производительности процессор/компилятор могут переставлять местами некоторые инструкции/операции.
 * Вернее, с точки зрения потока, наблюдающего за выполнением операций в другом потоке, операции могут быть выполнены
 * не в том порядке, в котором они идут в исходном коде.
 * <p>
 * Так же эффект реордеринга может наблюдаться, когда один поток кладет результаты первой операции в регистр или локальный
 * кэш, а результат второй операции кладет непосредственно в основную память. Тогда второй поток, обращаясь к основной
 * памяти может сначала увидеть результат второй операции, и только потом первой, когда все регистры или кэши
 * синхронизируются с основной памятью.
 * <p>
 * Еще одна причина reordering, может заключаться в том, что процессор может решить поменять порядок выполнения операций,
 * если, например, сочтет что такая последовательность выполнится быстрее.
 * <p>
 * На практике это может иметь очень печальные последствия. После всего вышесказанного, думаю, проблема в коде ниже
 * не нуждается в пояснениях:
 * <p>
 * //first thread
 * reslit = calc();
 * reslitReady = true
 * <p>
 * //second thread
 * if (reslitReady){
 * takeDesision(reslit);
 * }
 * <p>
 * Тут еще важно отметить, что для выполнения операций в рамках одного потока, спецификация JVM разрешает делать только
 * такой reordering, который приводит к абсолютно тем же результатам, если бы все операции выполнялись в порядке указанном
 * в исходном коде с точки зрения потока, в котором этот код выполняется. Т.е. в одном потоке reordering никогда не проявляется.
 */
public class SheepManager {

    private int sheepCount = 0;

    private void incrementAndReport() throws InterruptedException {
        System.out.print((++sheepCount) + " ");
        Thread.sleep(1000);
    }

    public static void main(String[] args) {

        // ++is not  thread-safe!!
        int i1 = 0, j = 0;

        i1 = i1-- + ++i1 + ++i1 + i1++; // 2
        j = j * (j++ + ++j);
//        System.out.println(i1);
//        System.out.println(j);


        ExecutorService service = null;
        try {
            service = Executors.newFixedThreadPool(30);
            SheepManager manager = new SheepManager();
            for (int i = 0; i < 10; i++)
                service.submit(() -> {
                    try {
                        manager.incrementAndReport();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                });
        } finally {
            if (service != null) service.shutdown();
        }
    }
}
