package web;

/**
 * http://www.javenue.info/post/81
 * Синхронизация по классу Atomicity говорит о том, что в один момент времени в synchronized блоке может находится
 * не больше одного потока. Остальные потоки будут ждать, для того чтобы захватить монитор класса Atomicity.
 * При чем случится это только после того, как активный поток отпустит этот монитор.
 */

/**
 * Атомарность говорит о том, что некоторое действие (или их последовательность) должно происходить "все и сразу".
 * Осутствие синхронизации может привести к катострофическим последствиям. Это далеко не NullPointerException,
 * который можно обнаружить сразу. Программа может работать достаточно долго и визаульно никаких неполадок обнаружено не будет.
 * При написании многопоточных приложений необходимо аккуратно следить за всеми возможными случаями проявления ошибок неатомарности.
 */

/*
И еще очень важное замечание - в соответствии с Java Memory Model записи в переменые типа long и double не являются атомарными.
Типы long и double являются 64-битными и атомарными считаются записи только в каждую 32-битную часть.
Это может привести к тому, что некоторый поток видит одну часть значения обновленной, а вторую еще нет.
Чтобы гарантировать атомарность записи в long и double необходимо объявлять их как volatile.
Кстати, запись ссылки на объект (reference) всегда атомарна, не зависимо от того, имеем мы дело с 32-х или 64-х битной реализацией JVM.
В Java Memory Model рассказано много еще чего интересного, например о видимости (Visibility) и упорядоченности (Ordering).
Но это уже совсем другая история.
 */
public class Atomicity extends Thread {
    volatile static int i;
    boolean b;

    public void run() {
        while (true) {
//            synchronized (Atomicity.class) {
                if (b = !b) i++;
                else i--;
//            }
        }
    }

    public static void main(String[] args) {
        new Atomicity().start();
        new Atomicity().start();

        while (true)
            System.out.println(i);
    }
}